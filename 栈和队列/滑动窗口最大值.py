'''
leetcode 239
题目：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。
返回滑动窗口最大值。
示例:
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]
解释:

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
注意：
你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。
解析：
1.暴力求解：时间复杂度为O(n*k),空间复杂度为O(1)
2.递增队列法：时间复杂度O(n),空间复杂度为O(k),维护一个递增队列
3.最大堆法：时间复杂度O(nlogk), 空间复杂度为O(1):每次插入以一个元素复杂度为O(logk)，获得最大值的时间复杂度为O(1)
'''

class Solution:
    def maxSlidingWindow(self, nums, k):
        result = []
        queue = []
        for i in range(len(nums)):
            if i >= k:
                result.append(queue[0])
                # 当前窗口左边为i-k+1，右边边界为i，则i-k为离左边边界最近的一个元素，如果这个元素恰好是队列头部节点。
                if nums[i-k] == queue[0]:
                    queue.pop(0)
            while len(queue) > 0 and nums[i] > queue[-1]:  # 队列不为空且队列中最后的元素大于当前元素，将队列最后元素出队，因为它不可能成为最小元素了
                queue.pop(-1)
            queue.append(nums[i])
        result.append(queue[0])
        return result